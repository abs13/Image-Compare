<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>image_compare API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>image_compare</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import os
from os import path
import functools
import csv
import traceback
from pprint import pprint
import errno

def getOSType():
    &#39;&#39;&#39;
        function to check the platform that the utility is running on and prints it on system out
            parameters:
                
            returns:
                a (str) : The type of OS in upper case ( Linux, Mac OS, Windows)
    &#39;&#39;&#39;
    import platform 
    my_platform = platform.system().upper() #
    if my_platform == &#39;WINDOWS&#39;:
        print (&#34;Running on Windows&#34;)
    elif my_platform == &#39;LINUX&#39; :
        print(&#34;Running on Linux&#34;)
    elif my_platform == &#39;DARWIN&#39;:
        print(&#34;Running on Mac OS&#34;)
    return(my_platform)

def backuponRerun(outcsvfile,verbosity):
    &#39;&#39;&#39;
        Function to create backup of previosuly generated files before creating new file.

        Checks for write permissions for new file.

        If no filename is passed. Create a default name
        
            parameters:
                a (str): Path to output csv file.
                b (str): Verbosity TRUE or FALSE
            returns:
                : Nothing
    &#39;&#39;&#39;
    import datetime #import datetime. This will be used to create a backup of the output file in case older output dile exists.
    import pathlib  #Import pathlib to handle paths and create backups of folders
    suffx_var = datetime.datetime.now().strftime(&#34;%Y_%m_%d_%H_%M_%S&#34;) # Calculate the suffix to append to old output file. Format is YYYY_MM_DD_H_M_S
    #open output file and insert the header into it
    if path.exists(outcsvfile):
        print(&#39;deault output file specified or re-run detected. Creating a backup&#39;)
        vfilebase = pathlib.Path(outcsvfile).stem # capture the filename without extension. 
        print(&#39;re-naming &#39; + outcsvfile)
        try:
            os.rename(outcsvfile,vfilebase + &#34;_&#34;+suffx_var + &#39;.csv&#39;) #regenerate the filename as &lt;file_name&gt;_&lt;Date Suffic&gt;.csv
            #check if can rename a file in the specified directory
        except PermissionError as permissionerr: # If permission denied, capture that and displat to user. Exit futher execution
            
            if verbosity is True:
                print(permissionerr)
                
                print (&#34;******************Premission Denied to rename old file&#34;)
                print()
                print (&#34;******************Check permissions and retry&#34;)
                exc_type, exc_value, exc_tb = sys.exc_info()
                pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
                exit(2)
            else:
                print(permissionerr)
                print(&#39;run utility with --verbose for detailed error&#39; )
        except IOError as ioerr: #If any other IO error  (e.g. DISK Full), Capture that , stop further execution and display the exception to user.
            if verbosity is True:
                print()
                exc_type, exc_value, exc_tb = sys.exc_info()
                pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
        
            else:
                print(ioerr)
                print(&#39;run utility with --verbose for detailed error&#39; )
        

def getimagehash(image1path,image2path):
    &#39;&#39;&#39;
        Function to compare images. 

        uses dhash as the hashing method

            parameters:
                a (str) : path to image 1
                b (str) : path to image 2
      
            returns: 
                a (int): diff of the two image hashes
    &#39;&#39;&#39;
    from PIL import Image
    import imagehash 
    #print(imagehash.__doc__)   
    myimghash1 = imagehash.dhash(Image.open(image1path,))
    myimghash2 = imagehash.dhash(Image.open(image2path))
    myhashdiff = myimghash1 - myimghash2
    return (myhashdiff) #return the difference between the dhashes of two input images
def cleanupEmpty():
    print(&#39;dummy&#39;)

def main(): #Function to generate the menu for the utility
    &#39;&#39;&#39;
        Generate help menu and manage command line arguments. Calls output file initialization and compare process functions

            -h (optional) displays the usage 

            -v (optional) displays the function

            -o (optional) capture the output filenname with path.

            -i (required) captures the input csv filename with path

                paramater: 
                    : Nothing
                returns: 
                    : Nothing
    &#39;&#39;&#39;
    import argparse
    #sys.tracebacklimit = 0
    parser = argparse.ArgumentParser(prog=&#39;image_compare&#39;,description=&#34;Use this to compare images&#34;) #initate the parser
    parser.version = &#34;1.0&#34; # Set version as 1.0. this can be displayed using the -v optional paramater
    parser.add_argument(&#39;-i&#39;,action=&#34;store&#34;,dest=&#39;input_file&#39;,help=&#34;Input csv containig paths of images to compare&#34;, required=True) #define a required param, to capture the input csv file
    parser.add_argument(&#39;-o&#39;,action=&#34;store&#34;, dest=&#34;output_file&#34;,type=str,default=&#39;output.csv&#39;) #define an option parameter for output file
    parser.add_argument(&#39;--verbose&#39;,action=&#34;store_true&#34;) #define a version param

    parser.add_argument(&#39;-v&#39;,action=&#34;version&#34;,) #define a version param
    my_arguments=parser.parse_args()
    csvtoread = my_arguments.input_file
    outcsvfile = my_arguments.output_file
    verbosity = my_arguments.verbose 
   
    backuponRerun(outcsvfile,verbosity) #call the fuction to initialize the output file. the called function only adds a header here
    processCompare(csvtoread,outcsvfile,verbosity) #Call the function to compare the file sets based on the paths provided in input csv file
def processCompare(csvtoread,outcsvfile,verbosity):
    &#39;&#39;&#39; 
        Takes two inputs, the input and output csv files. Loops over all lines in input csv and processes hash diffs.

        Calls the hash calculation function after making sure all I/O operations( permission and DISK space etc) are possible

            parameters:
                a (str) :  path to input csv
                b (str) :  path to output csv
            returns:
                    : nothing
    &#39;&#39;&#39;
    import timeit
    my_platform = getOSType() # get the OS type
    try:
        outputfile = open(outcsvfile , &#39;a&#39;) # check if output file can be opened for inserting new records ( in append mode )
        headernames = [&#39;Image1&#39;,&#39;Image2&#39;,&#39;Similar&#39;,&#39;Elapsed&#39;]
        writehandle = csv.DictWriter(outputfile,fieldnames=headernames)
        writehandle.writeheader()
    
    except PermissionError as permissionerr:
        
        if verbosity is True :
            print(permissionerr)
            exc_type, exc_value, exc_tb = sys.exc_info()
            pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
        else:
            print (&#39;******************Check permissions and retry******************&#39;)
            print()
            print(permissionerr)
    except IOError as ioerr: #capture any IO excpetions e.g. DISK FULL
        if verbosity is True :
            print(ioerr) 
            print()
            exc_type, exc_value, exc_tb = sys.exc_info()
            pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
        else:
            print(&#39;I/O Erro&#39;)
            print(&#39;run utility with --verbose&#39;)
        exit(2)
    else:
        
        
        if path.isfile(csvtoread) and path.getsize(csvtoread) &gt; 0 : #check if the input file provided by users exists and is a file
            try:
                my_input_cvs=open(csvtoread, &#39;r&#39;)
            
            except PermissionError as permissionerr: #capture any permission errors in case user does not have permissions to read the file
                if verbosity is True :
                    print(permissionerr)
                    exc_type, exc_value, exc_tb = sys.exc_info()
                    pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
                else:
                    print(permissionerr)
                    print (&#34;******************Check permissions and retry******************&#34;)
                    print()
                
            
            else:
             
                with my_input_cvs: #If no errors raised, continue processing the file
                    csvcontent = csv.reader(my_input_cvs) # read each line from file
                    next(csvcontent, None)  # skip the headers in the input csv file
                    itr_var = 1 #initialize a counter. this will be used to display the row number in case processing failes for any of the rows i csv file
                    for line in csvcontent: 
                        if not line : #if the line is empty, do nothing and moved to next
                            continue
                        else: #else continue processing
                            itr_var = itr_var + 1  
                            img1 = line[0] #get the path for first image file (marked for comparison in the input cvs)
                            print(img1)
                            img2 = line[1] #get path for the second image file ( marked for comparison in the input cvs)
                            print(img2)
                        
                        #check if the paths defined for image1 and image2 exist on the filesystem
                            if path.isfile(img1) and path.isfile(img2):
                                #call the imagehash calculater function to calculate the hashdiff of image1 and image2
                                myhashdiff = getimagehash(img1, img2)
                                #calculate time taken to calculate each hash by above function
                                execCost = timeit.timeit(stmt=functools.partial(getimagehash, img1, img2), number=100)
                                writehandle.writerow({&#39;Image1&#39;: img1,&#39;Image2&#39;: img2,&#39;Similar&#39;: myhashdiff,&#39;Elapsed&#39;: execCost})
                               
                            elif path.isfile(img1) == False and path.isfile(img2): # check for both images if the path defined exists.
                                print (img1 + &#34; not a valid path on row &#34; + str(itr_var) ) 
                                print (&#34;Skipping row &#34; + str(itr_var))

                            elif path.isfile(img1) and path.isfile(img2) == False:
                                print (img2 + &#34; not a valid path on row &#34; + str(itr_var))
                                print (&#34;Skipping row &#34; + str(itr_var))

                            elif path.isfile(img1) ==False and path.isfile(img2) == False:
                                print (img1 + &#34; and &#34; + img2 + &#34; not a valid path on row &#34; + str(itr_var))
                                print (&#34;Skipping row &#34; + str(itr_var))
            finally:
                outputfile.close()
                cleanupEmpty()
        elif path.isfile(csvtoread) and path.getsize(csvtoread) == 0:
            raise Exception(&#39;Input csv empty. Exiting....&#39;)
            exit()
        
        elif path.isfile(csvtoread) is False:
            raise FileNotFoundError (errno.ENOENT, os.strerror(errno.ENOENT), csvtoread)
            print(&#34;Input CVS file &#34; + csvtoread + &#39; does not exist.&#39; ) # If input csv path does not exist, inform the user.
            print(&#34;Please check path specified and try again&#34;)
            exit(2)
if __name__ == &#39;__main__&#39;:
    
    main() #Call the main function
                 </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="image_compare.backuponRerun"><code class="name flex">
<span>def <span class="ident">backuponRerun</span></span>(<span>outcsvfile, verbosity)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create backup of previosuly generated files before creating new file.</p>
<p>Checks for write permissions for new file.</p>
<p>If no filename is passed. Create a default name</p>
<pre><code>parameters:
    a (str): Path to output csv file.
    b (str): Verbosity TRUE or FALSE
returns:
    : Nothing
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backuponRerun(outcsvfile,verbosity):
    &#39;&#39;&#39;
        Function to create backup of previosuly generated files before creating new file.

        Checks for write permissions for new file.

        If no filename is passed. Create a default name
        
            parameters:
                a (str): Path to output csv file.
                b (str): Verbosity TRUE or FALSE
            returns:
                : Nothing
    &#39;&#39;&#39;
    import datetime #import datetime. This will be used to create a backup of the output file in case older output dile exists.
    import pathlib  #Import pathlib to handle paths and create backups of folders
    suffx_var = datetime.datetime.now().strftime(&#34;%Y_%m_%d_%H_%M_%S&#34;) # Calculate the suffix to append to old output file. Format is YYYY_MM_DD_H_M_S
    #open output file and insert the header into it
    if path.exists(outcsvfile):
        print(&#39;deault output file specified or re-run detected. Creating a backup&#39;)
        vfilebase = pathlib.Path(outcsvfile).stem # capture the filename without extension. 
        print(&#39;re-naming &#39; + outcsvfile)
        try:
            os.rename(outcsvfile,vfilebase + &#34;_&#34;+suffx_var + &#39;.csv&#39;) #regenerate the filename as &lt;file_name&gt;_&lt;Date Suffic&gt;.csv
            #check if can rename a file in the specified directory
        except PermissionError as permissionerr: # If permission denied, capture that and displat to user. Exit futher execution
            
            if verbosity is True:
                print(permissionerr)
                
                print (&#34;******************Premission Denied to rename old file&#34;)
                print()
                print (&#34;******************Check permissions and retry&#34;)
                exc_type, exc_value, exc_tb = sys.exc_info()
                pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
                exit(2)
            else:
                print(permissionerr)
                print(&#39;run utility with --verbose for detailed error&#39; )
        except IOError as ioerr: #If any other IO error  (e.g. DISK Full), Capture that , stop further execution and display the exception to user.
            if verbosity is True:
                print()
                exc_type, exc_value, exc_tb = sys.exc_info()
                pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
        
            else:
                print(ioerr)
                print(&#39;run utility with --verbose for detailed error&#39; )</code></pre>
</details>
</dd>
<dt id="image_compare.cleanupEmpty"><code class="name flex">
<span>def <span class="ident">cleanupEmpty</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanupEmpty():
    print(&#39;dummy&#39;)</code></pre>
</details>
</dd>
<dt id="image_compare.getOSType"><code class="name flex">
<span>def <span class="ident">getOSType</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>function to check the platform that the utility is running on and prints it on system out
parameters:</p>
<pre><code>returns:
    a (str) : The type of OS in upper case ( Linux, Mac OS, Windows)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOSType():
    &#39;&#39;&#39;
        function to check the platform that the utility is running on and prints it on system out
            parameters:
                
            returns:
                a (str) : The type of OS in upper case ( Linux, Mac OS, Windows)
    &#39;&#39;&#39;
    import platform 
    my_platform = platform.system().upper() #
    if my_platform == &#39;WINDOWS&#39;:
        print (&#34;Running on Windows&#34;)
    elif my_platform == &#39;LINUX&#39; :
        print(&#34;Running on Linux&#34;)
    elif my_platform == &#39;DARWIN&#39;:
        print(&#34;Running on Mac OS&#34;)
    return(my_platform)</code></pre>
</details>
</dd>
<dt id="image_compare.getimagehash"><code class="name flex">
<span>def <span class="ident">getimagehash</span></span>(<span>image1path, image2path)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to compare images. </p>
<p>uses dhash as the hashing method</p>
<pre><code>parameters:
    a (str) : path to image 1
    b (str) : path to image 2

returns: 
    a (int): diff of the two image hashes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getimagehash(image1path,image2path):
    &#39;&#39;&#39;
        Function to compare images. 

        uses dhash as the hashing method

            parameters:
                a (str) : path to image 1
                b (str) : path to image 2
      
            returns: 
                a (int): diff of the two image hashes
    &#39;&#39;&#39;
    from PIL import Image
    import imagehash 
    #print(imagehash.__doc__)   
    myimghash1 = imagehash.dhash(Image.open(image1path,))
    myimghash2 = imagehash.dhash(Image.open(image2path))
    myhashdiff = myimghash1 - myimghash2
    return (myhashdiff) #return the difference between the dhashes of two input images</code></pre>
</details>
</dd>
<dt id="image_compare.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate help menu and manage command line arguments. Calls output file initialization and compare process functions</p>
<pre><code>-h (optional) displays the usage

-v (optional) displays the function

-o (optional) capture the output filenname with path.

-i (required) captures the input csv filename with path

    paramater: 
        : Nothing
    returns: 
        : Nothing
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(): #Function to generate the menu for the utility
    &#39;&#39;&#39;
        Generate help menu and manage command line arguments. Calls output file initialization and compare process functions

            -h (optional) displays the usage 

            -v (optional) displays the function

            -o (optional) capture the output filenname with path.

            -i (required) captures the input csv filename with path

                paramater: 
                    : Nothing
                returns: 
                    : Nothing
    &#39;&#39;&#39;
    import argparse
    #sys.tracebacklimit = 0
    parser = argparse.ArgumentParser(prog=&#39;image_compare&#39;,description=&#34;Use this to compare images&#34;) #initate the parser
    parser.version = &#34;1.0&#34; # Set version as 1.0. this can be displayed using the -v optional paramater
    parser.add_argument(&#39;-i&#39;,action=&#34;store&#34;,dest=&#39;input_file&#39;,help=&#34;Input csv containig paths of images to compare&#34;, required=True) #define a required param, to capture the input csv file
    parser.add_argument(&#39;-o&#39;,action=&#34;store&#34;, dest=&#34;output_file&#34;,type=str,default=&#39;output.csv&#39;) #define an option parameter for output file
    parser.add_argument(&#39;--verbose&#39;,action=&#34;store_true&#34;) #define a version param

    parser.add_argument(&#39;-v&#39;,action=&#34;version&#34;,) #define a version param
    my_arguments=parser.parse_args()
    csvtoread = my_arguments.input_file
    outcsvfile = my_arguments.output_file
    verbosity = my_arguments.verbose 
   
    backuponRerun(outcsvfile,verbosity) #call the fuction to initialize the output file. the called function only adds a header here
    processCompare(csvtoread,outcsvfile,verbosity) #Call the function to compare the file sets based on the paths provided in input csv file</code></pre>
</details>
</dd>
<dt id="image_compare.processCompare"><code class="name flex">
<span>def <span class="ident">processCompare</span></span>(<span>csvtoread, outcsvfile, verbosity)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes two inputs, the input and output csv files. Loops over all lines in input csv and processes hash diffs.</p>
<p>Calls the hash calculation function after making sure all I/O operations( permission and DISK space etc) are possible</p>
<pre><code>parameters:
    a (str) :  path to input csv
    b (str) :  path to output csv
returns:
        : nothing
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def processCompare(csvtoread,outcsvfile,verbosity):
    &#39;&#39;&#39; 
        Takes two inputs, the input and output csv files. Loops over all lines in input csv and processes hash diffs.

        Calls the hash calculation function after making sure all I/O operations( permission and DISK space etc) are possible

            parameters:
                a (str) :  path to input csv
                b (str) :  path to output csv
            returns:
                    : nothing
    &#39;&#39;&#39;
    import timeit
    my_platform = getOSType() # get the OS type
    try:
        outputfile = open(outcsvfile , &#39;a&#39;) # check if output file can be opened for inserting new records ( in append mode )
        headernames = [&#39;Image1&#39;,&#39;Image2&#39;,&#39;Similar&#39;,&#39;Elapsed&#39;]
        writehandle = csv.DictWriter(outputfile,fieldnames=headernames)
        writehandle.writeheader()
    
    except PermissionError as permissionerr:
        
        if verbosity is True :
            print(permissionerr)
            exc_type, exc_value, exc_tb = sys.exc_info()
            pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
        else:
            print (&#39;******************Check permissions and retry******************&#39;)
            print()
            print(permissionerr)
    except IOError as ioerr: #capture any IO excpetions e.g. DISK FULL
        if verbosity is True :
            print(ioerr) 
            print()
            exc_type, exc_value, exc_tb = sys.exc_info()
            pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
        else:
            print(&#39;I/O Erro&#39;)
            print(&#39;run utility with --verbose&#39;)
        exit(2)
    else:
        
        
        if path.isfile(csvtoread) and path.getsize(csvtoread) &gt; 0 : #check if the input file provided by users exists and is a file
            try:
                my_input_cvs=open(csvtoread, &#39;r&#39;)
            
            except PermissionError as permissionerr: #capture any permission errors in case user does not have permissions to read the file
                if verbosity is True :
                    print(permissionerr)
                    exc_type, exc_value, exc_tb = sys.exc_info()
                    pprint(traceback.format_exception(exc_type,exc_value,exc_tb))
                else:
                    print(permissionerr)
                    print (&#34;******************Check permissions and retry******************&#34;)
                    print()
                
            
            else:
             
                with my_input_cvs: #If no errors raised, continue processing the file
                    csvcontent = csv.reader(my_input_cvs) # read each line from file
                    next(csvcontent, None)  # skip the headers in the input csv file
                    itr_var = 1 #initialize a counter. this will be used to display the row number in case processing failes for any of the rows i csv file
                    for line in csvcontent: 
                        if not line : #if the line is empty, do nothing and moved to next
                            continue
                        else: #else continue processing
                            itr_var = itr_var + 1  
                            img1 = line[0] #get the path for first image file (marked for comparison in the input cvs)
                            print(img1)
                            img2 = line[1] #get path for the second image file ( marked for comparison in the input cvs)
                            print(img2)
                        
                        #check if the paths defined for image1 and image2 exist on the filesystem
                            if path.isfile(img1) and path.isfile(img2):
                                #call the imagehash calculater function to calculate the hashdiff of image1 and image2
                                myhashdiff = getimagehash(img1, img2)
                                #calculate time taken to calculate each hash by above function
                                execCost = timeit.timeit(stmt=functools.partial(getimagehash, img1, img2), number=100)
                                writehandle.writerow({&#39;Image1&#39;: img1,&#39;Image2&#39;: img2,&#39;Similar&#39;: myhashdiff,&#39;Elapsed&#39;: execCost})
                               
                            elif path.isfile(img1) == False and path.isfile(img2): # check for both images if the path defined exists.
                                print (img1 + &#34; not a valid path on row &#34; + str(itr_var) ) 
                                print (&#34;Skipping row &#34; + str(itr_var))

                            elif path.isfile(img1) and path.isfile(img2) == False:
                                print (img2 + &#34; not a valid path on row &#34; + str(itr_var))
                                print (&#34;Skipping row &#34; + str(itr_var))

                            elif path.isfile(img1) ==False and path.isfile(img2) == False:
                                print (img1 + &#34; and &#34; + img2 + &#34; not a valid path on row &#34; + str(itr_var))
                                print (&#34;Skipping row &#34; + str(itr_var))
            finally:
                outputfile.close()
                cleanupEmpty()
        elif path.isfile(csvtoread) and path.getsize(csvtoread) == 0:
            raise Exception(&#39;Input csv empty. Exiting....&#39;)
            exit()
        
        elif path.isfile(csvtoread) is False:
            raise FileNotFoundError (errno.ENOENT, os.strerror(errno.ENOENT), csvtoread)
            print(&#34;Input CVS file &#34; + csvtoread + &#39; does not exist.&#39; ) # If input csv path does not exist, inform the user.
            print(&#34;Please check path specified and try again&#34;)
            exit(2)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="image_compare.backuponRerun" href="#image_compare.backuponRerun">backuponRerun</a></code></li>
<li><code><a title="image_compare.cleanupEmpty" href="#image_compare.cleanupEmpty">cleanupEmpty</a></code></li>
<li><code><a title="image_compare.getOSType" href="#image_compare.getOSType">getOSType</a></code></li>
<li><code><a title="image_compare.getimagehash" href="#image_compare.getimagehash">getimagehash</a></code></li>
<li><code><a title="image_compare.main" href="#image_compare.main">main</a></code></li>
<li><code><a title="image_compare.processCompare" href="#image_compare.processCompare">processCompare</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>